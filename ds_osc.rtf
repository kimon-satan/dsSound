{\rtf1\ansi\ansicpg1252\cocoartf1038\cocoasubrtf360
{\fonttbl\f0\fnil\fcharset0 Monaco;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue191;\red0\green115\blue0;\red191\green0\blue0;
}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural\pardirnatural

\f0\fs28 \cf0 \
\
(\
\
	~activeSynths = \cf2 Array\cf0 .newClear(20);\
	~activeTasks = \cf2 Array\cf0 .newClear(20);\
	~activeNames = \cf2 Array\cf0 .newClear(20);\
	\
\
	~init.remove;\
	~init=\cf2 nil\cf0 ;\
	~init = \cf2 OSCresponderNode\cf0 (\cf2 nil\cf0 , \cf3 '/init'\cf0 , \{\cf2 |i, r, msg|\cf0  \
	\
	(msg).postln;  \
	\
	\}).add;\
	\
	~wave.remove;\
	~wave=\cf2 nil\cf0 ;\
	~wave = \cf2 OSCresponderNode\cf0 (\cf2 nil\cf0 , \cf3 '/wave'\cf0 , \{\cf2 |i, r, msg|\cf0  \
	\
	msg.postln;\
	\cf4 // replaced saw with LFCub ... low freqs better for overall mix\cf0 \
	\
	\
	\{\
	\cf2 var\cf0  sig, env, sig1, env1, trig, out, ts;\
				\
		ts = 32;\
		trig = 1;\
		env = \cf2 EnvGen\cf0 .kr(\cf2 Env\cf0 .new([0,1,1,0],[0.4,0.4,0.2],[4,1,-4]),trig, timeScale:ts);\
		env1 = \cf2 EnvGen\cf0 .kr(\cf2 Env\cf0 .new([0,1,0],[0.8,0.2],[3,-4]), trig, timeScale:ts);\
		\
		sig = \cf2 LFCub\cf0 .ar(\cf2 Rand\cf0 (25,50),1) * 0.2 * \cf2 LFPulse\cf0 .kr(15,0,0.4,1) * env;\
		\cf4 //sig = HPF.ar(sig,XLine.kr(Rand(100,200),1000,ts));\cf0 \
		sig = \cf2 Pan2\cf0 .ar(sig,0);\
		sig1 = \cf2 LFPar\cf0 .ar(\cf2 Rand\cf0 (25,50),5).clip2(\cf2 Rand\cf0 (0.2,0.05)) * 0.3 * \cf2 LFPulse\cf0 .kr(15,0,0.6,1) * env1;\
		\cf4 //sig1 = HPF.ar(sig1,Rand(100,200));\cf0 \
		sig1 = \cf2 Pan2\cf0 .ar(sig1,0);\
\
		out = sig + sig1 * \cf2 EnvGen\cf0 .kr(\cf2 Env\cf0 .linen(0.001,1,0.001),trig,timeScale:ts, doneAction:2);\
		\
		\
	\}.play;\
				\
	\}).add;\
	\
	~nStar.remove;\
	~nStar =\cf2 nil\cf0 ;\
	~nStar = \cf2 OSCresponderNode\cf0 (\cf2 nil\cf0 , \cf3 '/newStar'\cf0 , \{\cf2 |i, r, msg|\cf0  \
	\
	\cf2 var\cf0  index;\
		msg.postln;	\
		\
		~activeNames[msg[1]] = msg[2];\
		if(msg[2] == \cf3 \\strobingRings\cf0 )\{~activeSynths[msg[1]] = \cf2 Synth\cf0 .new(\cf3 \\strobingRings\cf0 )\};		if(msg[2] == \cf3 \\strobingLines\cf0 )\{~activeSynths[msg[1]] = \cf2 Synth\cf0 .new(\cf3 \\strobingLines\cf0 )\};\
		if(msg[2] == \cf3 \\regPulsingRings\cf0 )\{~activeSynths[msg[1]] = \cf2 Synth\cf0 .new(\cf3 \\regPulsingRings\cf0 )\};\
		if(msg[2] == \cf3 \\statFlow\cf0 )\{~activeSynths[msg[1]] = \cf2 Synth\cf0 .new(\cf3 \\statFlow\cf0 )\};\
\
\
		\
	\}).add;\
	\
	~eStar.remove;\
	~eStar =\cf2 nil\cf0 ;\
	~eStar = \cf2 OSCresponderNode\cf0 (\cf2 nil\cf0 , \cf3 '/endStar'\cf0 , \{\cf2 |i, r, msg|\cf0  \
		\
		\cf2 var\cf0  index;\
		msg.postln;	\
		\
		~activeNames[msg[1]] = \cf2 nil\cf0 ;\
		if(~activeSynths[msg[1]] != \cf2 nil\cf0 )\{~activeSynths[msg[1]].set(\cf3 \\gate\cf0 , 0)\};\
		if(~activeTasks[msg[1]] != \cf2 nil\cf0 )\{~activeTasks[msg[1]].stop; ~activeTasks[msg[1]] = \cf2 nil\cf0 \}; \cf4 //stop any task\cf0 \
		\
	\}).add;\
	\
	~uStar.remove;\
	~uStar =\cf2 nil\cf0 ;\
	~uStar = \cf2 OSCresponderNode\cf0 (\cf2 nil\cf0 , \cf3 '/updateStar'\cf0 , \{\cf2 |i, r, msg|\cf0  \
		\
		\cf2 var\cf0  index;\
	\cf4 //	msg.postln;	\cf0 \
		\
		~activeSynths[msg[1]].set(\cf3 \\size\cf0 , msg[2]);\
		\
		if(msg[3] == 1)\{\
			\cf4 //start new task for that synth\cf0 \
			\
			if(~activeTasks[msg[1]] != \cf2 nil\cf0 )\{~activeTasks[msg[1]].stop; ~activeTasks[msg[1]] = \cf2 nil\cf0 \};\
			\
			if(~activeNames[msg[1]] == \cf3 \\strobingRings\cf0 )\{\
				~activeTasks[msg[1]] = \cf2 Task\cf0 (\{\
					\
					\cf2 var\cf0  n_pulse, n_width;\
					\
					if(msg[5] > 0,\
					\{n_pulse = rrand(18,22); n_width = 0.025\},\
					\{n_pulse = rrand(7,12); n_width = 0.7/n_pulse\}\
					);\
					\
					~activeSynths[msg[1]].set(\cf3 \\pulse\cf0 , n_pulse, \cf3 \\width\cf0 , n_width);\
					\
					(msg[4]/60).wait;\
					\
					~activeSynths[msg[1]].set(\cf3 \\pulse\cf0 , 15,\cf3 \\width\cf0 , 0.04);\
					\
				\}).start;\
			\
			\};\
			\
			if(~activeNames[msg[1]] == \cf3 \\strobingLines\cf0 )\{\
				\
				if(msg[5] < 0)\{\
					~activeTasks[msg[1]] = \cf2 Task\cf0 (\{\
						~activeSynths[msg[1]].set(\cf3 \\ch\cf0 , 1);\
						(msg[4]/60).wait;\
						~activeSynths[msg[1]].set(\cf3 \\ch\cf0 , 0);\
					\}).start;\
				\}\{\
					~activeTasks[msg[1]] = \cf2 Task\cf0 (\{\
						~activeSynths[msg[1]].set(\cf3 \\cut\cf0 , 0);\
						\cf2 Synth\cf0 .new(\cf3 \\strobingLinesEvent\cf0 , [\cf3 \\size\cf0 ,msg[2],\cf3 \\length\cf0 ,msg[4]/60]);\
						\
						(msg[4]/60).wait;\
						\
						~activeSynths[msg[1]].set(\cf3 \\cut\cf0 , 1);\
						\
					\}).start;\
					\
				\};\
				\
			\};\
			\
			if(~activeNames[msg[1]] == \cf3 \\regPulsingRings\cf0 )\{\
				\
				~activeTasks[msg[1]] = \cf2 Task\cf0 (\{\
					msg.postln;\
					\
					if(msg[5] > 0)\{\
					~activeSynths[msg[1]].set(\cf3 \\dur\cf0 , msg[4]/60, \cf3 \\gate1\cf0 , 1);\
					\}\{\
					~activeSynths[msg[1]].set(\cf3 \\dur\cf0 , msg[4]/60, \cf3 \\gate2\cf0 , 1);\
					\};\
					\
					0.1.wait;\
					\
					~activeSynths[msg[1]].set(\cf3 \\gate2\cf0 , 0, \cf3 \\gate1\cf0 , 0);\
					\
				\
				\}).start;\
			\};\
			\
			if(~activeNames[msg[1]] == \cf3 \\statFlow\cf0 )\{\
					if(msg[5] < 0)\{\
				~activeTasks[msg[1]] = \cf2 Task\cf0 (\{\
					msg.postln;\
					\
					~activeSynths[msg[1]].set(\cf3 \\gate\cf0 , 0);\
					\
					(msg[4]/60).wait;\
					\
					~activeSynths[msg[1]] = Synth.new(\\statFlow,[\\size, msg[2]]);\
				\
				\}).start;\
					\};\
			\};\
\
\
			\
		\};\
		\
	\}).add;\
\
\
)\
\
\
\
\
\
}